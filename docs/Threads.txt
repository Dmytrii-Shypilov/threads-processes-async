Multithreading -  is a way to run multiple tasks at the same time within the same program. Each "task" runs in a separate thread.

Use for:
1) File reads/writes
2) Network requests
3) User input
4) Database operations

Real-world Application Examples:
1) Web Crawlers / Scrapers
- Fetch many web pages at once using threads.
2) Chat Applications
- One thread listens for messages, another handles user input.
3) Downloading Multiple Files
- Download files in parallel instead of one by one.
4) Games
- One thread for game logic, one for rendering, another for handling inputs.
5) Server Monitoring Tools
- Continuously collect logs or metrics from multiple sources at the same time.

If youâ€™re doing heavy CPU calculations (like matrix operations, ML models), 
multithreading wonâ€™t help much in Python because of the GIL. Instead, use multiprocessing.

================== Threads vs Processes ==================
--- Threads ----
Multiple Threads - one single Process
All threads share the same memory
Limited by the GIL

Analogy:
- Like one person doing multiple things at once (boiling water, talking on the phone, waiting for an email). They're multitasking, but still one brain.

In Python, threads share the same memory space, so they can easily share data. 
But Python has a limit called the GIL (Global Interpreter Lock) â€” it allows only one thread to execute Python code at a time. 
So multithreading is best for I/O-bound tasks, not CPU-heavy work.

LOW overhead

---- Processes -------
Multiple processes, each has its own memory space.
No GIL limit â€” each process runs independently on different CPU cores.
Best for CPU-bound tasks (e.g., image processing, complex math, data crunching).

Analogy:
- Like having multiple people doing different tasks in parallel â€” each with their own brain. They donâ€™t share memory easily but work simultaneously.

HIGHER overhead (spawning processes)

========================== Async Await =====================================

Why async/await Can Be Better:
1) The GIL only affects Python code â€” and most I/O tasks (like waiting for a response or file read) 
2) Donâ€™t use CPU, so async I/O can switch tasks efficiently without threads.
3) Asyncio uses an event loop to handle many I/O tasks in a single thread â†’ no thread-safety issues, less overhead.
4) You can run thousands of tasks with asyncio, but spawning thousands of threads would be a mess.

Use async/await when:
1) Youâ€™re doing lots of network requests (e.g., web scraping, API calls).
2) You want efficient memory and performance.
3) Youâ€™re okay using async libraries (aiohttp, aiomysql, etc.).

===============================================

Recommendations for Processes, Threads, Async:

âœ… Use async/await for high-performance I/O-bound tasks
âœ… Use threading if you're using blocking libraries or mixing CPU and I/O
- A blocking library is one where functions stop the program until theyâ€™re done. (Need to offload to a Thread)
ðŸš« Donâ€™t use threading for CPU-bound tasks â€” use multiprocessing

